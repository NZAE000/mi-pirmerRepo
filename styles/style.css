/*Estilo en cascada:
	
		jerarquia:				!important
								estilo en linea
								identificadores	(id)
								clases			(class)
								pseudo-clases   (ej: hover)
								atributos		
								elementos
								pseudo-elementos

		conceptos:				*Responsive-design: adaptar la pagina a distintos dispositivos: moviles, pc, tablets, etc.
								*Medidas fijas(absolutas): cm, mm, pt, in, pc. Son aquellas que especifican una medida en términos absolutos, sin tener en cuenta el contexto donde se están aplicando.
								*Medidas relativas:
													%: porcentaje (depende de la caja que contiene tal elemnto)
													em: Altura de la fuente
													rem: Root-em
													vw: Viewport width
													vh: Viewport Height
													vmin: Viewport menor, entre altura o anchura
													vmax: Viewport mayor, entre altura o anchura
													ex: anchura de la fuente para la letra "x"
													ch: la anchura del carácter "0" (cero)

										Las unidades relativas de CSS son aquellas que tienen en cuenta el contexto donde se encuentran. Son relativas a las dimensiones del contenedor donde se han definido.

								*BOX-MODEL:
										-line-height: modifica el espacio vertical del texto.
										-text-aling: posiciona el texto de un contenedor(center, left, right).
						
										-display:
											inline: el elemento se renderizará en línea con otros elementos.
											block: hace que el comportamiento del elemento sea como un bloque. Los elementos hijos en block se adecuan al tamaño de la caja del padre.
											inline-block: se redereiza en linea con otros elementos pero a su vez adquiere propiedades como establecer un ancho y alto en el elemento.
										
										-box-sizing:
											border-box: Al cambiar de tamaño de alguna caja (ej: widht, height), no considera si el contenido tiene algun borde (border) o relleno (padding). 
											content-box: Si es que el contenido tiene borde o relleno, los considera al momento aplicar cambios de tamaño de la caja.

										-box-shadow: para la sombra. Parametros: (px(en X), px(en Y), px(desenfoque)), px(grosor borde), color).

										-padding:
												Para separar la distancia entre el contenido y los bordes de su caja. 
												Separacion en top, right, bottom y left (parametricamente funciona ej: padding: 10px 10px 20px 20px;)
										-border:
											
											border-radius: para redondear las esquinas de la box.
											border-top-width, border-right-width, border-botton-width, border-left-width: aumentar grosor;
											border color: para el color deborde.
											etc..
											Para simplificar estas propíedades en border:
												border: grosor(general) estilo(solid, dashed, double, groove, ridge, inset, outset) color;
											

										-margin:
												Para separar distancia entre una box a otra. Tales son top, right, bottom y left (parametricamente funciona ej: margin: 10px 10px 20px 20px)

										-position:
											static; los elementos se posicionan de acuerdo al flujo normal de la página. Es la posición natural de los elementos. No son afectados por las propiedades top, bottom, left y right.
											relative; los elementos se posicionan de forma relativa a su posición normal.
											fixed; los elementos se posicionan de forma relativa a la ventana del navegador. Su posición permanece fija aunque se desplace la ventana.
											absolute; los elementos se posicionan de forma relativa al primer elemento padre que tenga una posición distinta a static.

										-overflow: La propiedad CSS overflow especifica: si recortar contenido, dibujar barras de desplazamiento o mostrar el contenido excedente en un elemento a nivel de bloque.
										-transition: Las transiciones CSS le permiten cambiar los valores de propiedad sin problemas, durante un período determinado. Pase el mouse sobre el elemento de abajo para ver un efecto de transición de CSS(con all cabian todas las propiedades dictadas en ese trancurso de tiempo).
										-float: La propiedad float ubica un elemento al lado izquierdo o derecho de su contenedor, permitiendo a los elementos de texto y en línea aparecer a su costado. El elemento es removido del normal flujo de la página, aunque aún sigue siendo parte del flujo (a diferencia del posicionamiento absoluto).


								*Pseudo-elementos:

									Los pseudo-elementos en CSS son un mecanismo para acceder a partes del HTML(elementos) que no tienen asociado un nodo en el DOM. Por ejemplo, está claro que una «parte de nuestro documento» podría ser «la primera línea de un párrafo», «la primera letra de un párrafo» o «la selección que ha hecho el usuario». 
									selector::pseudo-elemento { propiedad: valor; }

										-first-line: no aplicable para 'display: inline'. El Pseudoelemento ::first-line aplica estilos a la primera línea de un elemento de bloque. Nótese que la longitud de la primera línea depende de muchos factores, incluyendo el ancho del elemento, el ancho del documento y el tamaño de fuente del texto.
										-fisrt-letter: el pseudo-elemento ::first-letter aplica estilos a la primera letra de la primera línea un elemento de bloque, sólo cuando no es precedido de otro contenido (como imágenes o tablas).
										-placeholder: El pseudo-elemento CSS  ::placeholder representa el texto provisional en un elemento <input> o un elemento <textarea>.
										-selection: El ::selection selector coincide con la parte de un elemento que selecciona un usuario(destaca). Solo se pueden aplicar algunas propiedades CSS al ::selector de selección: color, fondo, cursor y contorno.
										-before: En CSS, ::before crea un pseudoelemento que es el primer hijo del elemento seleccionado. Es usado normalmente para añadir contenido estético a un elemento, usando la propiedad content. Este elemento se muestra en línea con el texto de forma predeterminada.
										-after: En CSS, ::after crea un pseudo-elemento que es el último hijo del elemento seleccionado. Es comunmente usado para añadir contenido cosmético a un elemento con la propiedad content.Es en linea (inline) de forma predeterminada.
												
															a::after/before {
																 content: "→";
															}

								*Pseudo clases(eventos): elemento: pseudo-clase{};

									hover: se adquiqeren propiedaes a tal elemento que es indicado con el escenario de pasar por encima con el mouse;
									link: se adquieren pripiedades a los elementos a para indexar. Esas porpiedades existen solo si no fue visitada la pagina.
									visited: se comporta como la pseudo clase link pero cuando la pagina ya se visitó.
									active: se adiquieren propiedes a elemento donde son indicados por el evento de matener/presionar el click del mause.
									focus: se adquieren propiedades enfocado al elemento input, es decir al precionar dentro del input para alguna entrada.

								*Object-fit: La propiedad CSS object-fit indica cómo el contenido de un elemento reemplazado, por ejemplo un <img> o <video>, debería redimensionarse para ajustarse a su contenedor.
									object-fit: 'modo';

									contain: El contenido reemplazado está dimensionado para mantener su relación de aspecto mientras se ajusta dentro del cuadro de contenido del elemento.
									cover: El contenido reemplazado se dimensiona para mantener su relación de aspecto mientras llena el cuadro de contenido completo del elemento. Si la relación de aspecto del objeto no coincide con la relación de aspecto de su caja, entonces el objeto se recortará para que se ajuste.
									none: El contenido reemplazado no se redimensiona.
									scale-down: Elije la resolucion o el modo que mas convenga de acuerdo al contenedor.El contenido se dimensiona como si none o contain estuvieran especificados, lo que resultaría en un tamaño de objeto concreto más pequeño.

								*Object-position: determina el alineamiento del elemento dentro de la caja.
									object-position: 'modo'; (left, right, top, bottom, px, em , %, etc).

								*Cursor: especifica el tipo de cursor que se mostrara cuando este se encuentre sobre un elemento.									
									cursor: (pinte, row-resize, progress, copy)(modo); referecnia: https://www.w3schools.com/cssref/tryit.asp?filename=trycss_cursor.
								

								*flex-box: Diseño de Caja Flexible, comúnmente conocido como Flexbox​, es un modelo de diseño CSS3. Forma de estrucutar o maquetar una pagina.
										   Nos permite alinear, llenar o distribuir el espacio entre los elementos dentro de un 'contenedor', usando anchos y alturas flexibles. Esto, lo convierte en una gran herramienta para usar en sistemas de diseño responsivo.
									
									display: flex; <- si el contenedor padre adquiere esta propiedad, sus hijos o items seran flexibles (flex-items: solo sus hijos directos).

									flex-direction: cambia la direccion del main axis(eje x) a cross axis(eje y) o viceversa.
										-row: ordena todos sus items en fila (main axis, por defecto).
										-colum: ordena todos sus items en columna (cross axis).					
										-row-reverse: cambia el sentido del main axis(de derecha a izquierda) y ordena los items de esa forma.
										-colum-reverse: cambia el sentido del crossa axis(de abajo hacia arriba) y ordena los items de esa forma.

									flex-wrap: especifica si los elementos flexibles deben ajustarse o no.
										-wrap: especifica que los elementos flexibles se envolverán si es necesario(apilar al sentido del cross axis)
										-nowrap: valor por defecto. Especifica que los elementos flexibles no se envolverán.
										-wrap-reverse: Especifica que los elementos flexibles se envolverán, si es necesario, en orden inverso(apilar al contra-sentido del cross axis).

									flex-flow: abrevia las dos propiedes anteriores.
										flex-flow: colum wrap / row wrap / etc;

									justify-content: alinea los elementos del contenedor flexible cuando los elementos no utilizan todo el espacio disponible en el eje principal (horizontalmente).
										-center: los elementos o hijos directos del contenedor flex se colocan en el centro del contenedor.
										-space-around: Los elementos o hijos directos del contenedor flex tendrán espacio antes, entre y después de ellos.
										-space-between: Los elementos o hijos directos del contenedor flex  tendrán espacio entre ellos.
										-space-evenly: Los elementos tendrán el mismo espacio a su alrededor.

									align-items: especifica la alineación predeterminada para los elementos dentro del contenedor flexible (vertical)(utilizable para 'una linea' de items, ya que si se utiliza 'flex-wrapp: wrap', si se encoje la pagina la seguna linea pasa al centro. Para que no ocurra esto se utiliza align-content).
										-strech: por defecto. los elementos hijos directos del contenedor flexible se estiran a lo largo del cross axis para adaptarse al contenedor.
										-center: los elementos hijos directos del contenedor flexible se colocan en el centro del contenedor.
										-flex-end: los elementos hijos directos del contenedor flexible se colocan al final del contenedor.
										-flex-start: los elementos hijos directos del contenedor flexible se colocan al principio del contenedor.
										-baseline: los elementos hijos directos del contenedor flexible se colocan en la línea de base del contenedor.

									align-content: modifica el comportamiento de la propiedad flex-wrap. Es similar a align-items, pero en lugar de alinear elementos flexibles, alinea 'líneas' flexibles.

								*flex-items: propiedades solo para elementos o items flexibles, es decir, elementos dentro de un contenedor con display: flex.

									align-self: especifica la alineación del elemento seleccionado dentro del contenedor flexible.
										-auto: Defecto. El elemento hereda la propiedad align-items de su contenedor principal, o "estirar" si no tiene un contenedor principal.
										Los demas valores que provee esta propiedad son las mismas que tiene align-items

									margin: cuando los elementos o hijo directos son flex(estan dentro de un contenedor flex), el margin actua de manera contraria al margen normal. Es decir, si se le da un margin-lef, el margen izquierdo se engruesa de izquierda a derecha.
											Con margin: auto, centras el elemento al centro del contenedor flex.

									flex-grow: especifica cuánto crecerá el elemento-flex en relación con el resto de los elementos flexibles dentro del mismo contenedor (todos (o solo un elemento del contenedor) crece/n en proporcion al espacio que sobra del contenedor).
										flex-grow: 1,2,3..; (Un número que especifica cuánto crecerá el artículo en relación con el resto de los artículos flexibles. El valor predeterminado es 0).
									
									flex-shrink: especifica cómo se encogerá un elemento flex en relación con el resto de los artículos flexibles dentro del mismo contenedor..
										flex-shrink: 0, 1,2,3..; (Un número que especifica cuánto se encogerá el artículo en relación con el resto de los artículos flexibles. El valor predeterminado es 1. Con 0 no encoge).

									flex-basis: especifica la longitud inicial(como width, pero con mas jerarquia) de un elemento flexible(item dentro de u contenedor flex).

									flex: abrevia las tres propiedes anteriores.
										flex: 1(grow) 0(shrink) 350px(basis);

									order: especifica el orden de un elemento flexible en relación con el resto de los elementos flexibles dentro del mismo contenedor (Es como el z-index, pero en vez del eje z es en direccion al main axis).
										order: 1,2,3...; (Valor predeterminado 0. Especifica el orden del artículo flexible).

								*GRID: El módulo de diseño de cuadrícula ofrece un sistema de diseño basado en cuadrículas, con filas y columnas, lo que facilita el diseño de páginas web sin tener que usar flotadores y posicionamiento.

								*GRID-container: Para que un elemento HTML se comporte como un contenedor de cuadrícula (grillas), debe establecer la propiedad display grid o inline-grid. Hara que cambia la estructura de lo que contiene la caja o el contenedor.	

									display: grid; <- si el contenedor padre adquiere esta propiedad, sus hijos o items seran grid (grid-items: solo sus hijos directos).					
									
									grid-tamplate-rows: la cantidad de filas del contenedor de acuerdo a la cantidad de argumentos. Cada argumento tendra una medida, que es el espacio que ocupa cada una.
										grid-tamplate-rows: 150px 150px 50px 1fr; hay 4 filas, las dos primeras ocupan 150px de espacio, la tercera 50px y la cuarta sera semidinamica, osea ocupara el espacio sobrante y a su vez es estirable.
 										grid-tamplate-rows: repeat(3, 150px); Se le dice que se creen 3 filas, cada una de 150px de espacio.

									grid-tamplate-colum: la casntida de columnas del contenedor de acuerdo a la cantida de argumentos. Cada argumento tendra una medida, que es el espacio que ocupa cada una..
										grid-tamplate-colum: 2fr 250px 50px 100px 20; Cinco columnas cada una con su tamañp correspondiente.
										grid-tamplate-colum: repeat(5, 50px); Se le dice que se creen 5 columnas, cada una de 50px de espacio.

									grid-row-gap: para separar cada celdas(bordes) en filas del contendor;
										grid-row-gap: 50px;

									grid-colum-gap: para separar cada celdas(bordes) en columnas del contendor;
										grid-colum-gap: 20px;

									grid-gap: para separar cada una de las celdas(bordes) en filas y columnas del contenedor entre ellas.
										grid-gap: 25px;

									grid-auto-flow: controla cómo funciona el algoritmo de colocación automática, especificando exactamente cómo los elementos colocados automáticamente fluyen hacia la cuadrícula.
										grid-auto-flow: row; Los elementos se colocan llenando cada fila por turno, agregando nuevas filas según sea necesario.
										grid-auto-flow: column; Los elementos se colocan llenando cada columna por turno, agregando nuevas columnas según sea necesario.
										grid-auto-dense: ;

								*GRID-item: todos lo elementos que estan adentro de un grid-container(los que existen, porque si la cuadricula es de 2x2 y solo existe un elemento por ej <h1>, habria solo un grid-items. El resto sera grid-cell).
									
									grid-row-start: un elemento por defecto empiezan de tal linea de inicio en fila. Con esta propiedad se puede modificar de que linea en fila empieze tal item.
										grid-row-start: 2; El elemento empezara desde la segunda linea en fila.

									grid-row-end: un elemento por defecto termina su espacio a tal linea final en fila. Con esta propiedad de puede modificar hasta que linea final en fila termine tal elemento.
										grid-row-end: 4; El elemento ocupara espacio hasta la cuarta linea en fila.

									grid-colum-start: un elemento por defecto empiezan de tal linea de inicio en columna. Con esta propiedad se puede modificar de que linea en columna empieze tal item.
										grid-colum-start: 3; El elemento empezara desde la tercera linea en columna.

									grid-colum-end: un elemento por defecto termina su espacio a tal linea final en columna. Con esta propiedad de puede modificar hasta que linea final en columna termine tal elemento.
										grid-colum-end: 6; El elemento ocupara espacio hasta la sexta linea en columna.

									grid-row: abrevia desde que linea hasta que linea en fila ocupara espacio tal item.
										grid-row: 1 / 3; tal elemetno empieza a ocupar desde la primera linea hasta la tercera linea en fila.
										grid-row: 1 / span 3; con span se le dice: tal elemetno que empieze desde la linea 1 y que ocupe 3 filas.

									grid-colum: abrevia desde que linea hasta que linea en columna ocupara espacio tal item.
										grid-colum: 2 / 4; tal elemetno empieza a ocupar desde la segunda linea hasta la cuarta linea en columna.
										grid-row: 2 / span 4; con span se le dice: tal elemetno que empieze desde la linea 2 y que ocupe 4 columnas.

								*GRID-IMPLICIT: Si uno o los elemento/s en el DOM no tienen un tamaño explicitado en grid-template-rows o colum, se crean filas o columnas implícitas en la grilla.

									grid-auto-rows: especifíca el tamaño de las filas creadas de forma implícita (siempre que grid-auto-flow: row);
									grid-auto-columns: especifíca el tamaño de las columnas creadas de forma implícita (siempre que grid-auto-flow: column);

								*GRID-DINAMICOS(funciones):

									minmax(): define un rango de tamaño mayor o igual que min y menor o igual que max.
										grid-template-colum: repeat(3, minmax(100px, 250px)); (al encojer o estirar la ventana las cuadriculas encojeran hasta 100px y se estiraran hasta 250px).
										grid-template-colum: repeat(3, minmax(min-content, 250px)); (al encojer la ventana, las cuadriculas en columnas se encojeran hasta su contenido).
										grid-template-colum: repeat(3, minmax(100px, max-content)); (al estirar la ventana, las cuadriculas en columnas se estiraran hasta su contenido).

									auto-fill: LLENA la fila con tantas columnas como pueda caber. Por lo tanto, crea columnas implícitas siempre que una nueva columna puede caber, porque está tratando de LLENAR la fila con tantas columnas como sea posible. Las columnas recién agregadas pueden estar vacías, pero seguirán ocupando un espacio designado en la fila.
										grid-template-colum: repeat(autofill, minmax(100px, 1fr));

									auto-fit: escala todos elementos;
								
								*ALINIACIÓN PARA GRID-CONTEINER

									justify-items: alinea los elementos de la cuadrícula a lo largo del eje de la fila (en línea). Específicamente, esta propiedad le permite establecer la alineación de los elementos dentro de un contenedor de cuadrícula (no la cuadrícula en sí) en una posición específica.
										stretch; (default)
										center;
										start;
										end;
									align-items: alinea los elementos de la cuadrícula a lo largo del eje de la columna (en línea).;
										stretch; (default)
										center;
										start;
										end;

								*ALINIACIÓN PARA GRID-FILAS-COLUMNAS
									
									align-content: alinea las filas;
										center;
										start;
										end;
										space-around;
										space-between;
										space-evenly;
									justify-content: alinea las columnas;
										center;
										start;
										end;
										space-around;
										space-between;
										space-evenly;

								*ALINIACIÓN PARA GRID-ITEMS

									align-self: alinea algun elemento o elementos dentro en grid de manera vertical;
										center;
										start;
										end;
									justify-self: alinea algun elemento o elementos dentro en grid de manera horizontal;
										center;
										start;
										end;
									place-self: abreviacion para los dos anteriores;
										place-self: end start; (al final en vertical y al inicio en horizontal)

									order: especifica el orden de un elemento grid en relación con el resto de los elementos dentro del mismo contenedor grid (Es como el z-index, pero en vez del eje z es en direccion del contenedor).
										order: 1,2,3...; (Valor predeterminado 0. Especifica el orden del artículo grid).
								
								*grid-area: son areas que se seleccionan de forma consecutivas, es decir, por ej: seleccionamios un area de celdas de 3x3 o un conunto de 4x2 (siemopre consecutivas, es decir, formando figura cuadrada).
									grid-template-areas: se utiliza para dividir un contenerdor grilla en areas a traves de nombres.
									ej:
										grid-template-areas: "header header header"
															 "aside main main"
															 "aside main main"
															 "footer footer footer"
									grid-area: para indicarle a un elemento de un contenerdor grid a que area pertenece en grid-template-areas.
									ej:
										.my-header{
											grid-area: header;
										}
								
								*grid-line: estan las row-lines y las colum-lines. Es decir las lineas en filas y en columnas son las que visualizan las celdas. Se puede abarcar un area definida dandole nombres a la lineas.
									ej:	
										.grid-container{
											display: grid;
											grid-template-rows:n (tambien posible para las colums)
												[first-line]	
												150px
												[second-line]
												150px
												[t-line]
												150px
												[f-line]
												150px;
										}										
										luego..

										.grid-item:first-child{ (elijo el primer hijo)
											grid-row: first-line/t-line; (el primer hijo tendra una area desde la primera linea hasta la tercera, osea abarcara dos columnas de 150px)

										}

								*grid-cell: son cada una de las celdas de cuatro lineas que conforman el grid-container.

								*grid-tracks: estan los dos tipos: grid-row y grid-colum, osea el conjunto de celdas en filas o en columnas. El numero de tracks es el numero de filas + numero de columnas.

							*RESPONSIVE-DESIGN: Adaptar la pagina a distintos dispositivos: moviles, pc, tablets, etc. 

								-Estructuras flexibles (contenedores flexibles, imagenes y videos flexibles)
								-Media Queries:
									@media: se usa en consultas de medios para aplicar diferentes estilos para diferenetes tipos / dispositivos de medios.
									Los media Queries son condicionales:
										SI EL..
										_ancho y alto de la ventana gráfica 
										_ancho y alto del dispositivo
										_orientación (¿la tableta / telefono esta en modo vertical u horizontal?)
										_resolución

								-Hay 4 tipos de media Queries:
										-all (apto para todos los dispositivos)
										-print (destinado a material impreso  visualización de documentos en una pantalla en el modo de vista previa de impresión)
										-screen (destinado principalmente a las pantallas)
										-speech (destinado a sintetizadores de voz)

								-Operadores: OR | AND

								-Orientacion: landscape(mas ancho que largo (escritorio)) y portrait(mas largo que ancho (móvil))

								-METODOLOGIAS:

										-MOBILE_FIRST
										-DESKTOP_FIRST
										-CONTENT_FIRST

							*TRANSITION: ;

*/																		

/**{ 							'*' selector universal, osea selecciona todos los elementos del html.
	color: red;
}*/

/*h2, h3, ol, etc.. {			selector por elemento.
	color: red;
}*/

/*.lista-ejemplos{				selector por clase (usad cuando un etiqueta padre otorgue una propiedad que compartan todas sus etiquetas hijas).
	color: green;
}*/

/*#Descripcion{		     		selector por id (el valor de id debe ser unico para un elemento(tratar de no usar mas elementos con el mismo valor de id)).
	color: yellow;
}*/


/*li[id="index-pag2"]{			selector por atributo (cuando varias etiquetas comparten "el mismo nombre de atributo", pero refiriendose a tal con un valor en particular)
	color: pink;
}*/

body{
	display: flex; 
	flex-direction: column; 		/*sus hijos directos(header y footer) se ordenearan en columnas.*/
	background-color: #99ff9999;
	background-image: url("../img/html.png");
	background-repeat: no-repeat;
	background-position: center;
	width: 100vw;
	min-height: 120vh;
}
/*body img[src="img/html.png"]{
	align-self: center;
	padding-top: 12%;
	position: absolute;
	z-index: -1;
}*/
/*---------------------------------------------------------------------------------------------------------------*/

header{
	display: flex;
	flex-direction: column;
	width: 100vw;				 /*viewport: medidas relativas para el renderizado en dispositivos(se adapta a las medidas del hardware)*/
	height: 10vh;
	background-color: #00330c99;
	opacity: 95%;				 /*trasnparencia*/
}
header a{
	position: fixed;
	align-self: flex-end;
	margin-right: 1.5%;
	margin-top: 1%;
	font-size: 2.5em; 			/*1em = 16px 'en general' (dependiendo del navegador).*/
	border-radius:6px;
	box-shadow: 3px 3px 10px 5px #045, 3px 3px 10px 5px #045, 3px 3px 10px 5px #045;
	transition: all 0.4s;
	color: #069;	
	text-shadow: 2px 2px 5px #87ceeb;
}
header a:hover{
	transform: scale(1.1);
	transition: all 0.4s;
}

/*---------------------------------------------------------------------------------------------------------------*/

h1{
	margin-left: 2%;
	font-size: 4.5em;
	color: #006a9f;
}

/*---------------------------------------------------------------------------------------------------------------*/

h2{	
	margin: 4% 0;
	font-size: 2.5em;
	color: #006a9f;
	align-self: center;
}
#Descripcion{
	margin: 0 5%;
	align-self: center;
}
#Descripcion p{
	text-shadow: 3px 3px 5px #87ceeb, 2px 2px 5px #87ceeb, 2px 2px 5px #87ceeb;
	color: #059;
}
#Descripcion p a{		   		/*selector por descendiente(de tal elemento con id(y tambien posible por clase) selecciono un hijo(en su ambito {}) y asi ..)*/
	color: #069;
	text-decoration: none;
	transition: all 0.2s;
}
#Descripcion p a:hover{		   	/*:hover = pseudo-clase*/
	font-size: 1.07em;
	color: #00660099;
	transition: all 0.3s;
}

/*---------------------------------------------------------------------------------------------------------------*/

h3{
	text-align: center;
	margin-top: 8%;
	font-size: 25px; 
	color: #0095df;
	text-shadow: 1px 1px 1px #bfeaff;
}
nav{
	align-self: center;
	margin-top: 3%;
}
#lista_ejem{
	display: flex;
	font-size: 16px;
}
.ejem__index{	
	width: 200px;
	height: 30px;
	margin-left: 2%;
	text-align: center;
	padding-top: .4%;
	border-radius: 3px;
	box-shadow: 2px 2px 10px 4px #045;
	transition: transform 0.7s, background-color .5s;
}
.ejem__index a{
	text-decoration: none;
	font-size: 1.2em; 			/*para todos sus nodos hijos, el font size para la medida relativa 1em= 16px. la unidad em es escalable y siempre depende de su elemento padre. Como lista_ejem es la caja padre, entonces para la propiedad font-size, 1em = 16px*/
	/*line-height: 2;			las letras por defecto ocupan 1 line-height, osea 0.5 hacia arriba y hacia abajo de 'ESPACIO' (su caja) desde 'el centro de cada letra'(osea el espacio por defecto que ocpupa la letra). En este caso le decimos que ocupe 0.6*/
	color: #059;
	text-shadow: 1px 1px 5px #00cc0066;
	transition: all 1s;
}
.ejem__index:hover{ 				
	background-color: #d3ffcc;
	transform: scale(1.1);
	transition: transform 0.7s, background-color 1s;
}
.ejem__index:hover > a{
	text-shadow: none;
	font-weight: 800;
	color: #0809;
	transition: all .3s;
}
/*.ejem__index--active{ para darle propiedades solo a la etiqueta de esa clase que tiene el posfijo --active en html(se puede cambiar el posfijo a otras etiqueta manipulando con js).
	color: #059;
}*/

/*---------------------------------------------------------------------------------------------------------------*/

footer{
	display: flex;
	flex-direction: column;
	justify-content: center;
	position: fixed; bottom: 0.05vh;
	width: 100vw;
	height: 8.5vh;
	background-color: #1d511599;
	opacity: 95%;
}
footer p1{
	color:gold;
}
#redes-sociales{
	align-self: flex-end;
	padding-right: 1%;
	/*z-index: -1; ya que redes-sociales es hijo de footer y se sobrepone en lac caja footer, z-index al decirle -1 se anula footer pasaria a interponer en su hijo.*/
}
.contacto{
	width: 80px;
	margin-left: 2vw;
	font-family: Century Gothic;
	color: white;
	text-shadow: 2px 2px 7px #fff;	
	text-decoration: none;
}
.contacto:hover{
	color: gold;
}
.contacto img{
	margin-left: .5em;
}
footer p2{
	align-self: flex-end;
	margin-top: .5%;
	padding-right: 2.5%;
	color:gold;
}
footer p2 i{
	position: relative; left: 20px;
	color :#891010;
	text-shadow: 1px 1px 3px pink;
	font-family: Century Gothic;
}

@media screen and (max-width: 1220px){
	h2{	
		margin-top: 10%;
		font-size: 2.5em;
	}
	h3{
		font-size: 40px;
		margin-top: 10%;
	}
	#lista_ejem{
		flex-direction: column;
	}
	.ejem__index{
		width: 330px;
		height: 45px;
		padding-top: 1%;
		margin: 2% 0;
		font-size: 1.5em; 
	}
}
@media screen and (max-width: 700px){
	header a{
		font-size: 2em;
	}
	body{
		background-size: 130%;
	}
	h1{
		align-self: center;
		margin-top: 15%;
		font-size: 3.5em;
	}
	h2{	
		margin-top: 8%;
		font-size: 2.2em;
	}
	#Descripcion p{
		font-size: 13px;
	}
	h3{
		font-size: 30px;
	}
	.ejem__index{
		width: 250px;
		height: 30px;
		font-size: 1.1em; 
	}
	#redes-sociales, footer p2{
		font-size: 14px;
	}
}
@media screen and (max-width: 500px){
	header a{
		font-size: 2em;
	}
	h1{
		margin: 18% 0;
		font-size: 3em;
	}
	h2{	
		margin-top: 10%;
		font-size: 2em;
	}
	#Descripcion p{
		font-size: 10px;
	}
	h3{
		font-size: 25px;
		margin-top: 12%;
	}
	.ejem__index{
		width: 180px;
		height: 20px;
		font-size: .8em; 
	}
	#redes-sociales, footer p2{
		align-self: center;
		font-size: 12px;
	}
}